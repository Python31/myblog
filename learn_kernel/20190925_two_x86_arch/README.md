[x86架构：有了开放的架构，才能打造开放的营商环境](https://time.geekbang.org/column/article/89417)


## 计算机的工作模式

![image](https://user-images.githubusercontent.com/12036324/65565078-72203780-df81-11e9-9955-dc56cb255e78.png)

CPU包含三个部分：
- 运算单元：只管算，例如做加法，位移等。
运算单元计算的数据每次都要经过总线到内存里面拿，这样太慢了，所以就有了数据单元
- 数据单元：包含CPU内部的缓存和寄存器组，空间小速度快，可以暂时存放数据和运算结果
有了存数据的，有了计算的，谁去指挥的还没有，所以就出现了控制单元
控制单元：统一的指挥中心，它可以获得下一条指令然后执行这条指令。这条指令会指导运算单元取出数据单元的某几个数据，计算出结果，然后放在数据单元的某个地方。

![image](https://user-images.githubusercontent.com/12036324/65565088-78161880-df81-11e9-9fc1-6190ffce7c68.png)

CPU的控制单元里面有个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停的将代码段的指令拿进来，然后放入寄存器。
当前指令包含两个部分：
- 做什么操作：交给运算单元
- 操作哪些数据：数据单元
数据单元和运算单元做的事情：
- 数据单元：从*数据段*读到数据寄存器里，就可以参与运算了
- 运算单元：运算单元做完运算，产生的结果会暂存在数据单元的*数据寄存器*里面，最终会有指令将数据写回内存中的数据段


总线上又两类数据：
- 地址数据：我想拿内存中的哪个位置的数据，叫做地址总线
- 真正数据：真正的数据，数据总线

这两类总线的传递的数据的位数的区别：
- 地址总线：决定了能访问的地址范围又多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。
- 数据总线：决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。

## X86平台
- 标准
- 开放
- 兼容

![image](https://user-images.githubusercontent.com/12036324/65565112-895f2500-df81-11e9-845f-976ef165de5a.png)


## 8086的原理

![image](https://user-images.githubusercontent.com/12036324/65565137-a0057c00-df81-11e9-819a-d721cf919aec.png)

### 数据单元
为了暂存数据，8086 处理器内部有 8 个 16 位的通用寄存器，也就是刚才说的 CPU 内部的数据单元，分别是 AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。

这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。

### 运算单元

IP 寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。


如果要切换进程，每个进程分为自己的代码段和数据段，为了指向不同进程的地址空间，又四个16位的段寄存器：
- CS：代码段寄存器，通过它可以找到代码在内存中的位置
- DS：数据段寄存器，通过它可以找到数据在内存中的位置
- SS：栈寄存器：不用多说
- ES：扩展寄存器


## 32位处理器

在开放的架构上如何保持兼容呢，

### 通用寄存器

从16位增加到32位。

### 指令指针寄存器IP
也从16位变为32位

### 段寄存器

因为原来的模式其实有点不伦不类，因为它没有把 16 位当成一个段的起始地址，也没有按 8 位或者 16 位扩展的形式，而是根据当时的硬件，弄了一个不上不下的 20 位的地址。这样每次都要左移四位，也就意味着段的起始地址不能是任何一个地方，只是能整除 16 的地方。


那我们索性就重新定义一把吧。CS、SS、DS、ES 仍然是 16 位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是*段描述符*（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为*选择子*。

这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。


这样段起始地址就会很灵活了。当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。


这样就不兼容了，咋办呢？好在后面这种模式灵活度非常高，可以保持将来一直兼容下去。前面的模式出现的时候，没想到自己能够成为一个标准，所以设计就没这么灵活。

![image](https://user-images.githubusercontent.com/12036324/65565037-59178680-df81-11e9-9257-142592b71dec.png)

改良后32位的CPU的模式被称为保护模式，以前的被称为实模式。

当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行，只不过快了一点而已。


当需要更多内存的时候，你可以遵循一定的规则，进行一系列的操作，然后切换到保护模式，就能够用到 32 位 CPU 更强大的能力。


## 总结

![image](https://user-images.githubusercontent.com/12036324/65564991-3f763f00-df81-11e9-8a0d-42c519374a36.png)

![image](https://user-images.githubusercontent.com/12036324/65565007-4b620100-df81-11e9-8f57-41cb5424ad3d.png)


## 参考

- [x86 Assembly Guide](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)

