
## 虚拟内存如何映射到物理内存

虚拟内存分为用户空间 + 内核模块。

内核空间是共享的。


进程把虚拟内存映射为物理内存是通过MMU

CPU中的TLB缓存了MMU，所以进程切换会影响效率。

创建虚拟内存和物理内存映射得到过程：

1. 当用户访问虚拟内存的时候，发现在MMU中没有对应的物理地址
2. 触发缺页中断
3. 进入内核空间分配物理内存
4. 更新进程页表
5. 返回用户空间，恢复进程运行


## 虚拟内存的空间分布

![](./vmem.png)

1. 只读段：代码 + 常量
2. 数据段：全局变量
3. 堆：动态分配的内存，从低地址向上增长
4. 栈：局部变量 + 函数上下文。大小是固定了一般是8MB
5. 文件映射段：动态库、共享内存，从高地址向下增长


## 内存分配和释放

### 分配

- 小内存使用blk
    + 会缓存下来不会归还，提高内存访问效率，但是会造成内存碎片
- 大快内存使用mmap
    + 用完之后直接归还，申请频繁的时候会造成内存管理压力变大


### 回收

- 手动回收：free/unmap
- 系统自动回收（发现内存紧张）：
    + LRU
    + SWAP
    + OOM杀死进程

## proc文件系统是什么

用户和内核交互的特殊文件系统。

## buffer和cache的区别是什么

buffer 是对磁盘数据的缓存，cache是对文件数据的缓存，都包括读和写。


## 磁盘和文件的区别

磁盘也是一种文件，但是它上面没有文件系统，当有文件系统之后挂在到某个目录，就能在这个目录下进行读写文件了。


## 可能发生内存泄漏的情况

- 栈：由系统自动分配和管理，是局部变量会被自动回收
- 堆：由程序自己申请的（比如malloc），需要程序明确调用库函数（free）来释放他们，就会造成内存泄漏。
- 只读段（代码和常量）：只读的不会去分配新的内存，所以不会产生新的内存泄漏
- 数据段（全局变量和静态变量）：在定义的时候就已经确定好了，不会产生内存泄漏
- 内存映射（动态链接库和共享内存）：由程序动态分配和管理的

出现内存泄漏不仅自己不能访问，系统也不能把它再分配给应用。

## 内存紧张，系统怎么办
- 回收内存
- OOM杀死进程


## 什么是内存回收

- 文件页： buffer/cache
    + 大部分可以直接回收
    + 对于脏页（暂时还没写入磁盘的数据），就得先写入磁盘，然后释放内存。
    + 脏页可以通过fsync系统调用或者让内核线程的pdflush负责这些脏页的刷新
- 匿名页：程序动态分配的堆内存

## 内核如何定期回收内存


kswapd0是专门的内核线程来定期回收内存。

![](./kswapd0.png)

- 内存小于页最小阈值（pages_min）：内存都耗尽了，只有内核才能分配内存
- 内存大于最小阈值（pages_min）小于页低阈值（pages_low）：内存压力比较大，kswapd0可以开始执行了，只到剩余内存大于页高阈值（pages_high）
- 内存大于页低阈值（pages_low）小于页高阈值（pages_high）：有一定压力，但是能满足内存申请
- 内存大于页高阈值（pages_high）：没有内存压力


能通过*/proc/sys/vm/min_free_kbytes*设置最小阈值，低阈值和高阈值的算法如下：
```shell
pages_low = pages_min*5/4
pages_high = pages_min*3/2
```

## 
